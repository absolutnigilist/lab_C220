#include <string>
#include <iostream>
#include <cstdint>
#include <algorithm>
#include <iterator>
#include <memory>
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <set>
#include <type_traits>
#include <stack>
#include <queue>



#include "Header.h"
#include "Range.h"
#include "MyArray.h"

using namespace std;

int main()
{


	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 1. Реализуйте вычисление факториала с помощью constexpr-функции.
	//
	//Подсказки/напоминания: 
	//		- constexpr – функция должна состоять из единственной инструкции return <выражение>; (пока!)
	//		- но это выражение может включать вызов другой constexpr – функции, в частности рекурсивный
	//		  вызов 
	//		- если параметр рекурсивной constexpr- функции - это константа, компилятор вычислит результат
	//		  на этапе компиляции

	//Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции (если в качестве
	//				параметра используется константа, известная компилятору на этапе компиляции).
	//				Для проверки достаточно создать встроенный массив с размерностью, вычисляемой
	//				посредством constexpr-функции:

	{	//Например:
		int ar[factorial(3)];				//размерность массива будет вычеслена на этапе компиляции factorial(3) = 6

		//или								
		constexpr int n = factorial(5);   // Использование результата функции для инициализации constexpr переменной, будет вычислено как 120 на этапе компиляции 
		int ar1[n];						

		//попробуйте:
		int m = 7;							//Попытка использовать не constexpr переменную в качестве аргумента
		//constexpr int n1 = factorial(m);	// Это вызовет ошибку компиляции, так как m не является константой времени компиляции
		//int ar1[n1];

		//а так?							Использование результата constexpr функции для инициализации обычной переменной
		int n2 = factorial(m);				//factorial(m) будет вычислено во время выполнения программы, так как m не является константой времени компиляции.
		__asm nop
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 2a. Перевод с помощью пользовательского литерала из двоичного представления строкового
	//в значение, например: строку "100000000" -> в значение 256
	//Проверить результат посредством префикса 0b
	//Чтобы вызов пользовательского литерала выглядел просто и читаемо, например: 100000000_b
	//логично использовать пользовательский литерал с единственным параметром - const char*

	//Так как речь идет о литералах, логично вычислять значения на этапе компиляции
	// => реализуйте пользовательский литерал посредством constexpr - функций
	//Подсказка/напоминание: 
	//		- constexpr – функция должна состоять из единственной инструкции return <выражение>;
	//		- но это выражение может включать вызов другой constexpr – функции,
	//		- которая может быть рекурсивной (если параметр такой функции - это константа,
	//		  компилятор вычислит результат вызова рекурсив	ной функции на этапе компиляции)

	{
		auto value = 100000000_b; // Использование пользовательского литерала для перевода "100000000" в число
		std::cout << "Binary 100000000 as decimal is: " << value << std::endl;
		std::cout << "Check with 0b prefix: " << 0b100000000 << std::endl;
		__asm nop

	}

	//Задание 2b. Перевод в строковое двоичное представление, например: 256 -> "0b100000000"
	//Так как строка может быть любой длины, логичнее и проще возвращать объект std::string
	//=> возвращаемое значение не может быть constexpr!
	//Подсказка: манипулятора std::bin пока нет => преобразование в двоичную строку
	//придется делать вручную
	//Подсказка: количество разрядов в байте определяет константа CHAR_BIT - <cstdint>

	{
		std::string sBin= toBinStr(256);
		std::cout << "Binary representation of 256 is: " << sBin << std::endl;
		__asm nop
	}


	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 3. constexpr - объекты 
	//Создать класс (шаблон класса?) для хранения и манипулирования диапазоном значений.
	//В классе должны быть:
	//	переменные для хранения минимального и максимального значений,
	//	методы для получения каждого из значений
	//	метод для проверки - попадает ли указанное значение в диапазон
	//	метод, который получает любое значение данного типа и формирует результирующее значение:
	//							если принадлежит диапазону, то его и возвращаем
	//							если меньше минимального значения, возвращаем минимальное
	//							если больше максимального значения, возвращаем максимальное

	//Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции. 

	{
		constexpr Range<int> intRange(10, 20);

		// Проверяем, попадает ли значение в диапазон
		std::cout << "15 is within range: " << intRange.contains(15) << std::endl; // Должно вывести: 1 (true)

		// Проверяем, как метод clamp обрабатывает различные значения
		std::cout << "Clamping 5 (below min): " << intRange.clamp(5) << std::endl;  // Должно вывести: 10 (min value)
		std::cout << "Clamping 15 (within range): " << intRange.clamp(15) << std::endl; // Должно вывести: 15
		std::cout << "Clamping 25 (above max): " << intRange.clamp(25) << std::endl; // Должно вывести: 20 (max value)

		// Компилятор вычисляет значение на этапе компиляции для constexpr объектов
		constexpr int clampedValue = intRange.clamp(5);
		std::cout << "Clamped value (constexpr): " << clampedValue << std::endl; // Должно вывести: 10
		__asm nop
	}
	/***************************************************************/
//Задание 4.
	/*
	Реализуйте шаблон функции для печати любых последовательностей (vector, list, deque, set и встроенного массива), которые могут содержать:
	•	как объекты любого типа,
	•	так и указатели на объекты любого типа (указатели распечатывать неинтересно => в этом случае следует получать значение по адресу)
	Подсказки: if constexpr
	*/
	{
		std::vector<int> v = { 1, 2, 3, 4, 5 };
		std::list<int*> l = { new int(6), new int(7), new int(8) };
		std::deque<float> d = { 9.1f, 10.2f, 11.3f };
		std::set<std::string> s = { "Hello", "World" };
		int ar[] = { 1,2,3,4,5 };
		std::vector<std::string*> vv{ new std::string("aaa"), new std::string("bbb") };
		
		PrintSequence(vv);
		PrintSequence(l);
		PrintSequence(d);
		PrintSequence(s);
		PrintSequence(ar);
		PrintSequence(vv);
		__asm nop

	}

	/***************************************************************/
	//Задание 5.
		/* Реализуйте шаблон функции сложения двух значений.
		Если первое слагаемое является вектором, то все элементы вектора нужно увеличить на значение второго параметра. При этом элементы вектора и второй параметр должны быть одного и того же типа.
		Подсказки: if constexpr, is_same
		*/
	{
		std::vector<int> vec = { 1, 2, 3 };
		auto resultVec = Add(vec, 5);
		for (auto v : resultVec) {
			std::cout << v << " "; // Вывод: 6 7 8
		}
		std::cout << std::endl;
		__asm nop
	}


	/***************************************************************/
//Задание 6.
	/* 	Реализуйте шаблон функции вывода на печать значений элементов любого адаптера (stack, queue, priority_queue)
	Подсказки: if constexpr, is_same
	Предусмотрите вывод значений, если в адаптере хранятся указатели.
	*/
	{
		std::stack<int> s;
		s.push(1); s.push(2); s.push(3);
		PrintAdapter(s);
		std::stack<int, std::vector<int>> s2;
		s2.push(1); s2.push(2); s2.push(3);
		PrintAdapter(s2);

		std::queue<int*> q;
		int a = 4, b = 5, c = 6;
		q.push(&a); q.push(&b); q.push(&c);
		PrintAdapter(q);

		
		
		std::priority_queue<int> pq;
		pq.push(7); pq.push(8); pq.push(9);
		PrintAdapter(pq);
		std::priority_queue<int, std::vector<int>, Comparator> pq1;
		pq1.push(7); pq1.push(8); pq1.push(9);
		PrintAdapter(pq1);
	}

	/***************************************************************/
//Задание 7.
	/* 	Реализуйте шаблон constexpr функции Smth(), которая должна возвращать значения разного типа
	Подсказки: constexpr, if constexpr
	*/
	constexpr int res1 = Smth<int>();		// res1 = 1
	constexpr double res2 = Smth<double>(); // res2 = 2.2
	std::string res3 = Smth<const char*>();				// res3 = "abc"

	std::cout << "res1: " << res1 << "\n";
	std::cout << "res2: " << res2 << "\n";
	std::cout << "res3: " << res3 << "\n";


	//***************************************************************/
	//Задание 8.

	/*Пользовательский deduction guide – для вывода типов параметров шаблона
	Задан шаблон класса, который инкапсулирует внедренный ограниченный массив известной
	размерности с элементами любого типа. */
	/*
	template<typename T, size_t size> class MyArray
		{
			T ar[size]; //как обеспечить инициализацию элементов базового типа по умолчанию нулем?
			…
			public:
			MyArray(const T*[, возможно другие параметры]);
		};
	*/
		
	//Требуется обеспечить работоспособность приведенных примеров использования.
		{
		MyArray<int, 5> ar1;				//MyArray<int,5>
		MyArray<char, 5> ar2{"ABCqwerty"};	//MyArray<char,5>
		MyArray ar3{"ABC"};					//MyArray<char,4>
		int ar[] = { 1,2,3 };
		MyArray ar4{ ar };
		}
		return 0;

}